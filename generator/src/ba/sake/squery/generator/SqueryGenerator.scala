package ba.sake.squery.generator

import java.nio.file.Paths
import java.nio.file.Path
import javax.sql.DataSource
import java.sql.{Array => _, _}
import scala.collection.decorators._
import scala.util._
import org.apache.commons.text.CaseUtils
import com.typesafe.scalalogging.Logger
import scala.meta._
import scala.meta.dialects.Scala34
import ba.sake.regenesca._
import ba.sake.squery.generator.ColumnType.Predefined
import ba.sake.squery.generator.ColumnType.Unknown

class SqueryGenerator(ds: DataSource, config: SqueryGeneratorConfig = SqueryGeneratorConfig.Default) {
  private val logger = Logger(getClass.getName)

  private val Preamble = "/* Autogenerated by Squery generator */"
  private val merger = SourceMerger(mergeDefBody = false)
  private val generator = RegenescaGenerator(merger)
  /*
  def generateString(schemaNames: Seq[String]): String = {
    val extractor = DbDefExtractor(ds)
    val dbDef = extractor.extract()
    val missingSchemaNames = schemaNames.toSet.diff(dbDef.schemas.map(_.name).toSet)
    if (missingSchemaNames.nonEmpty)
      throw new RuntimeException(s"Schemas do not exist in database: ${missingSchemaNames.mkString(", ")}")

    schemaNames
      .map { schemaName =>
        dbDef.schemas.find(_.name == schemaName) match {
          case Some(schemaDef) =>
            logger.info(s"Started generating schema '${schemaName}'")
            val (imports, enumDefsScala, tableDefsScala) = generateSchema(schemaDef, dbType = dbDef.tpe)
            val res =
              s"""|${Preamble}
                  |${imports}
                  |
                  |${enumDefsScala.map(_.content).mkString("\n")}
                  |
                  |${tableDefsScala.map(_.content).mkString("\n")}
                  |""".stripMargin
            logger.info(s"Finished generating schema '${schemaName}'")
            res
          case None =>
            throw new RuntimeException(s"Schema '${schemaName}' does not exist")
        }
      }
      .mkString("\n")
  }*/

  def generateFiles(schemaConfigs: Seq[SchemaConfig]): Unit = {
    val extractor = DbDefExtractor(ds)
    val dbDef = extractor.extract()
    val missingSchemaNames = schemaConfigs.map(_.name).toSet.diff(dbDef.schemas.map(_.name).toSet)
    if (missingSchemaNames.nonEmpty)
      throw new RuntimeException(s"Schemas do not exist in database: ${missingSchemaNames.mkString(", ")}")

    schemaConfigs.foreach { schemaConfig =>
      dbDef.schemas.find(_.name == schemaConfig.name) match {
        case Some(schemaDef) =>
          logger.info(s"Started generating schema '${schemaConfig.name}' into '${schemaConfig.baseFolder}'")
          val packagePath = schemaConfig.basePackage.replaceAll("\\.", "/")
          val (modelFiles, daoFiles) =
            generateSchema(schemaDef, dbType = dbDef.tpe, basePackage = schemaConfig.basePackage, fileGen = true)
          val modelFilesAdapted = modelFiles.map { gsf =>
            gsf.copy(file = schemaConfig.baseFolder.resolve(packagePath).resolve("models").resolve(gsf.file.toString))
          }
          val daoFilesAdapted = daoFiles.map { gsf =>
            gsf.copy(file = schemaConfig.baseFolder.resolve(packagePath).resolve("daos").resolve(gsf.file.toString))
          }
          generator.generate(modelFilesAdapted)
          generator.generate(daoFilesAdapted)
          logger.info(s"Finished generating schema '${schemaConfig.name}'")
        case None =>
          throw new RuntimeException(s"Schema '${schemaConfig.name}' does not exist")
      }
    }
  }

  private def generateBaseImports(dbType: DbType) = {
    val dbSpecificPackageName = Term.Name(dbType.squeryPackage)
    val dbSpecificPackageTerm = q"ba.sake.squery.${dbSpecificPackageName}"
    val importeesnel = List(importee"*", importee"given")
    val importers = List(importer"${dbSpecificPackageTerm}.{..$importeesnel}")
    List(
      q"import java.time.*",
      q"import java.util.UUID",
      q"import ba.sake.squery.{*, given}",
      q"import ..${importers}",
      q"import ba.sake.squery.read.SqlRead",
      q"import ba.sake.squery.write.SqlWrite"
    )
  }
  private def generateDaoImports(dbType: DbType, basePackage: String) = {
    val basePackageName = Term.Name(basePackage)
    val modelsPackageTerm = q"${basePackageName}.models"
    val importeesnel = List(importee"*")
    val importers = List(importer"${modelsPackageTerm}.{..$importeesnel}")
    generateBaseImports(dbType) ++
      List(q"import ..${importers}")
  }

  // (models, daos)
  private def generateSchema(
      schemaDef: SchemaDef,
      dbType: DbType,
      basePackage: String,
      fileGen: Boolean
  ): (Seq[GeneratedFileSource], Seq[GeneratedFileSource]) = {
    val enumDefs = schemaDef.tables.flatMap {
      _.columnDefs.map(_.scalaType).collect { case e: ColumnType.Enumeration =>
        e
      }
    }
    val enumFiles = enumDefs.map { enumDef =>
      val enumCaseDefs = Defn.RepeatedEnumCase(
        List.empty,
        enumDef.values.toList.map { enumDefCaseValue =>
          Term.Name(enumDefCaseValue)
        }
      )
      val enumName = enumDef.safeTypeName
      val enumTypeName = Type.Name(enumName)

      val basePackageRef = Term.Name(basePackage)
      val source =
        if (fileGen)
          source"""
          package ${basePackageRef}.models
          ..${generateBaseImports(dbType)}
          enum ${enumTypeName} derives SqlRead, SqlWrite {
            ${enumCaseDefs}
          }
          """
        else
          source"""
          enum ${enumTypeName} derives SqlRead, SqlWrite {
            ${enumCaseDefs}
          }
          """
      GeneratedFileSource(Paths.get(s"${enumName}.scala"), source)
    }

    val tableFiles = schemaDef.tables.map { tableDef =>
      val tableName = s"${tableDef.schema}.${tableDef.name}"
      val tableNameLit = Lit.String(tableName)
      val caseClassName = tableDef.name.safeTypeName + config.rowTypeSuffix
      val caseClassType = Type.Name(caseClassName)
      val objectRef = Term.Name(caseClassName)

      val columnNames = tableDef.columnDefs.map(_.metadata.name)
      val columnNamesScala = columnNames.map(_.safeColNameIdentifier)
      val allColsLit = Lit.String(columnNames.mkString(", "))

      // TODO def allColValues in a case class, easy inserts
      val caseClassDefn = locally {
        val columnParams = tableDef.columnDefs.map { columnDef =>
          val columnTpe = columnDef.scalaType match {
            case Predefined(tpe) => tpe
            case other => Type.Name(other.safeTypeName)
          }
          val tpe = if (columnDef.metadata.isNullable) t"Option[${columnTpe}]" else columnTpe
          // in case class we preserve RAW COLUMN NAMES !
          param"${Term.Name(columnDef.metadata.name)}: ${tpe}"
        }
        val pkTpe = t"PK"
        val pkType = t"${objectRef}.${pkTpe}"
        val pkValue = // TODO handle no PK
          if (tableDef.pkColumns.length == 1) {
            val pkCol = tableDef.pkColumns.head
            Term.Name(pkCol.metadata.name)
          } else {
            val pkColExprs = tableDef.pkColumns.map { pkCol =>
              Term.Name(pkCol.metadata.name)
            }
            q"${objectRef}.PK(..${Term.ArgClause(pkColExprs.toList)})"
          }
        q"""
        case class ${caseClassType}(
          ..${Term.ParamClause(columnParams.toList)}
        ) derives SqlReadRow {
          def pk: ${pkType} = ${pkValue}
        }
        """
      }

      val objectDefn = locally {

        val columnNameConsts = tableDef.columnDefs.map { columnDef =>
          val columnNameIdentifier = Pat.Var(name = Term.Name(columnDef.metadata.name.safeColNameIdentifier))
          // p"${columnDef.metadata.name.safeColNameIdentifier}"
          val columnNameLit = Lit.String(columnDef.metadata.name)
          q"""inline val ${columnNameIdentifier} = ${columnNameLit}"""
        }
        val pkTypeDef = // TODO handle no PK
          if (tableDef.pkColumns.length == 1) {
            val pkCol = tableDef.pkColumns.head
            q"type PK = ${Type.Name(pkCol.scalaType.safeTypeName)}"
          } else {
            val pkCols = tableDef.pkColumns.map { pkCol =>
              param"${Term.Name(pkCol.metadata.name)}: ${Type.Name(pkCol.scalaType.safeTypeName)}"
            }
            q"case class PK(..${Term.ParamClause(pkCols.toList)})"
          }
        val objectStmts = List(q"inline val tableName = ${tableNameLit}") ++
          columnNameConsts ++
          List(q"inline val allCols = ${allColsLit}") ++
          List({
            val withPrefixColumnNames = columnNames
              .map { columnName =>
                val colWithDotLit = Lit.String(s".${columnName}")
                q""" prefix + ${colWithDotLit} """
              }
              .reduceLeft((a, b) => q""" ${a} + "," + ${b} """)
            q"""transparent inline def allColsWithPrefix(inline prefix: String) =
              ${withPrefixColumnNames}
            """
          })
        q"""
        object ${Term.Name(caseClassName)} {
          ..${objectStmts}
          ${pkTypeDef}
        }
        """
      }

      val basePackageRef = Term.Name(basePackage)
      val source =
        if (fileGen)
          source"""
          package ${basePackageRef}.models
          ..${generateBaseImports(dbType)}
          ${caseClassDefn}
          ${objectDefn}
          """
        else
          source"""
          ${caseClassDefn}
          ${objectDefn}
          """
      GeneratedFileSource(Paths.get(s"${caseClassName}.scala"), source)
    }

    val daoFiles = schemaDef.tables.map { tableDef =>
      val rowClassName = tableDef.name.safeTypeName + config.rowTypeSuffix
      val rowClassType = Type.Name(rowClassName)
      val rowObjectRef = Term.Name(rowClassName)

      val tableName = s"${tableDef.schema}.${tableDef.name}"
      val tableNameLit = Lit.String(tableName)
      val tableNameSelect = q"${rowObjectRef}.tableName"

      val columnNames = tableDef.columnDefs.map(_.metadata.name)
      val allColsLit = Lit.String(columnNames.mkString(", "))
      val allColsSelect = q"${rowObjectRef}.allCols"
      val pkTpe = t"PK"
      val pkType = t"${rowObjectRef}.${pkTpe}"

      val daoClassName = tableDef.name.safeTypeName + config.daoTypeSuffix
      val daoClassType = Type.Name(daoClassName)
      val daoObjectName = Term.Name(daoClassName)

      // (literals, vars) for manually stitching the sql"" interpolation
      def byIdWhereExpr(prefix: String): (List[Lit], List[Term]) = {
        val prefixRef = Term.Name(prefix)
        if (tableDef.hasCompositePk) {
          val lits = tableDef.pkColumns.zipWithIndex
            .map { case (pkCol, i) =>
              if (i == 0)
                Lit.String(s"${pkCol.metadata.name} = ")
              else
                Lit.String(s" AND ${pkCol.metadata.name} = ")
            }
          val vars = tableDef.pkColumns.map { pkCol =>
            val pkColRef = Term.Name(pkCol.metadata.name)
            q"${prefixRef}.${pkColRef}"
          }
          lits.toList -> vars.toList
        } else {
          val pkCol = tableDef.pkColumns.head
          val pkColRef = Term.Name(pkCol.metadata.name)
          if (prefix == "row") List(Lit.String(s"${pkCol.metadata.name} = ")) -> List(q"${prefixRef}.${pkColRef}")
          else List(Lit.String(s"${pkCol.metadata.name} = ")) -> List(prefixRef)
        }
      }

      val genCountAll =
        q"""def countAll(): DbAction[Int] =
              sql"SELECT COUNT(*) FROM $${${tableNameSelect}}".readValue()
        """
      val genCountWhere =
        q"""def countWhere(whereQuery: Query): DbAction[Int] =
              sql"SELECT COUNT(*) FROM $${${tableNameSelect}} WHERE $${whereQuery}".readValue()
        """

      val genFindAll =
        q"""def findAll(): DbAction[Seq[${rowClassType}]] =
              sql"SELECT $${${allColsSelect}} FROM $${${tableNameSelect}}".readRows()
        """
      val genFindAllWhere =
        q"""def findAllWhere(whereQuery: Query): DbAction[Seq[${rowClassType}]] =
              sql"SELECT $${${allColsSelect}} FROM $${${tableNameSelect}} WHERE $${whereQuery}".readRows()
        """
      val genFindWhere =
        q"""def findWhere(whereQuery: Query): DbAction[${rowClassType}] =
              sql"SELECT $${${allColsSelect}} FROM $${${tableNameSelect}} WHERE $${whereQuery}".readRow()
        """
      val genFindWhereOpt =
        q"""def findWhereOpt(whereQuery: Query): DbAction[Option[${rowClassType}]] =
              sql"SELECT $${${allColsSelect}} FROM $${${tableNameSelect}} WHERE $${whereQuery}".readRowOpt()
        """
      val genFindById = Option.when(tableDef.hasPk) {
        val (whereLits, whereVars) = byIdWhereExpr("id")
        val sqlInterpolate = Term.Interpolate(
          Term.Name("sql"),
          parts = List(
            Lit.String("SELECT "),
            Lit.String(" FROM "),
            Lit.String(s" WHERE ${whereLits.head.value}") // merge "WHERE" and "id =" into ONE LITERAL!
          ) ++ whereLits.tail ++ List(Lit.String("")),
          args = List(allColsSelect, tableNameSelect) ++ whereVars
        )
        q"""def findById(id: ${pkType}): DbAction[${rowClassType}] =
              ${sqlInterpolate}.readRow()
        """
      }
      val genFindByIdOpt = Option.when(tableDef.hasPk) {
        val (whereLits, whereVars) = byIdWhereExpr("id")
        val sqlInterpolate = Term.Interpolate(
          Term.Name("sql"),
          parts = List(
            Lit.String("SELECT "),
            Lit.String(" FROM "),
            Lit.String(s" WHERE ${whereLits.head.value}") // merge "WHERE" and "id =" into ONE LITERAL!
          ) ++ whereLits.tail ++ List(Lit.String("")),
          args = List(allColsSelect, tableNameSelect) ++ whereVars
        )
        q"""def findByIdOpt(id: ${pkType}): DbAction[Option[${rowClassType}]] =
              ${sqlInterpolate}.readRowOpt()
        """
      }
      val genFindByIds = Option.when(tableDef.hasPk && !tableDef.hasCompositePk) {
        val sqlInterpolate = Term.Interpolate(
          Term.Name("sql"),
          parts = List(
            Lit.String("SELECT "),
            Lit.String(" FROM "),
            Lit.String(s" WHERE ${tableDef.pkColumns.head.metadata.name} IN ("),
            Lit.String(")")
          ),
          args = List(allColsSelect, tableNameSelect, Term.Name("idsExpr"))
        )
        q"""def findByIds(ids: Set[${pkType}]): DbAction[Seq[${rowClassType}]] = {
              val idsExpr = ids.map(id => sql"$${id}").reduce(_ ++ sql"," ++ _)
              ${sqlInterpolate}.readRows()
            }
        """
      }

      // TODO if cols are autoinc
      // https://www.jooq.org/doc/latest/manual/sql-building/sql-statements/insert-statement/insert-returning/
      val genInsert = {
        val colValues = tableDef.columnDefs
          .map { colDef =>
            val rowTerm = q"row"
            val colTerm = Term.Name(colDef.metadata.name)
            q"${rowTerm}.${colTerm}"
          }
        if (dbType.supportsReturning) {
          val sqlInterpolate = Term.Interpolate(
            Term.Name("sql"),
            parts =
              List(Lit.String(s"INSERT INTO ${tableNameLit.value}(${allColsLit.value}) \n    VALUES (\n      ")) ++
                tableDef.columnDefs.tail.map(_ => Lit.String(",")) ++
                List(Lit.String(s"\n    )\n    RETURNING ${allColsLit.value}")),
            args = colValues.toList
          )
          q"""def insert(row: ${rowClassType}): DbAction[${rowClassType}] =
                ${sqlInterpolate}.insertReturningRow()
              """
        } else {
          val sqlInterpolate = Term.Interpolate(
            Term.Name("sql"),
            parts = List(Lit.String(s"INSERT INTO ${tableNameLit.value}(${allColsLit.value}) \nVALUES (\n      ")) ++
              tableDef.columnDefs.tail.map(_ => Lit.String(",")) ++
              List(Lit.String(s"    \n)")),
            args = colValues.toList
          )
          q"""def insert(row: ${rowClassType}): DbAction[Int] =
                ${sqlInterpolate}.insert()
              """
        }
      }

      val genUpdateById = Option.when(tableDef.hasPk && tableDef.nonPkColDefs.nonEmpty) {
        val (whereLits, whereVars) = byIdWhereExpr("row")
        val updateLits = tableDef.nonPkColDefs.zipWithIndex
          .map { case (col, i) =>
            if (i == 0) Lit.String(s"${col.metadata.name} = ")
            else Lit.String(s", ${col.metadata.name} = ")
          }
        val updateVars = tableDef.nonPkColDefs.map { col =>
          val prefixRef = Term.Name("row")
          val colRef = Term.Name(col.metadata.name)
          q"${prefixRef}.${colRef}"
        }
        val sqlInterpolate = Term.Interpolate(
          Term.Name("sql"),
          parts = List(Lit.String("UPDATE "), Lit.String(s"\n    SET ${updateLits.head.value}")) ++
            updateLits.tail ++
            List(Lit.String(s"\n    WHERE ${whereLits.head.value}")) ++
            whereLits.tail ++ List(Lit.String("")),
          args = List(tableNameSelect) ++ updateVars ++ whereVars
        )
        q"""def updateById(row: ${rowClassType}): DbAction[Int] =
              ${sqlInterpolate}.update()
            """
      }

      val genDeleteWhere =
        q"""def deleteWhere(whereQuery: Query): DbAction[Int] =
              sql"DELETE FROM $${${tableNameSelect}} WHERE $${whereQuery}".update()
        """
      val genDeleteById = Option.when(tableDef.hasPk) {
        val (whereLits, whereVars) = byIdWhereExpr("id")
        val sqlInterpolate = Term.Interpolate(
          Term.Name("sql"),
          parts = List(
            Lit.String("DELETE FROM "),
            Lit.String(s" WHERE ${whereLits.head.value}") // merge "WHERE" and "id =" into ONE LITERAL!
          ) ++ whereLits.tail ++ List(Lit.String("")),
          args = List(tableNameSelect) ++ whereVars
        )
        q"""def deleteById(id: ${pkType}): DbAction[Int] =
              ${sqlInterpolate}.update()
        """
      }
      def genDeleteByIds = Option.when(tableDef.hasPk && !tableDef.hasCompositePk) {
        val pkColName = Term.Name(tableDef.pkColumns.head.metadata.name.safeColNameIdentifier)
        val pkColRef = q"${rowObjectRef}.${pkColName}"
        q"""def deleteByIds(ids: Set[${pkType}]): DbAction[Int] =
              val idsExpr = ids.map(id => sql"$${id}").reduce(_ ++ sql"," ++ _)
              deleteWhere(sql"$${${pkColRef}} IN ($${idsExpr})")
        """
      }

      val generatedDefs = List(
        Some(genCountAll),
        Some(genCountWhere),
        Some(genFindAll),
        Some(genFindAllWhere),
        Some(genFindWhere),
        Some(genFindWhereOpt),
        genFindById,
        genFindByIdOpt,
        genFindByIds,
        Some(genInsert),
        genUpdateById,
        Some(genDeleteWhere),
        genDeleteById,
        genDeleteByIds
      ).flatten

      val daoClassDefn = q"""
      class ${daoClassType} {
        ..${generatedDefs}
      }
      """
      val daoObjectDefn = q"""
      object ${daoObjectName} extends ${Init(daoClassType, Name.Anonymous(), List.empty)}
      """

      val basePackageRef = Term.Name(basePackage)
      val source =
        if (fileGen)
          source"""
          package ${basePackageRef}.daos
          ..${generateDaoImports(dbType, basePackage)}
          ${daoClassDefn}
          ${daoObjectDefn}
          """
        else
          source"""
          ${daoClassDefn}
          ${daoObjectDefn}
          """
      GeneratedFileSource(Paths.get(s"${daoClassName}.scala"), source)
    }

    (enumFiles ++ tableFiles, daoFiles)
  }

  private def transformName(str: String, nameMapper: NameMapper, capitalizeFirstLetter: Boolean): String =
    nameMapper match {
      case NameMapper.Noop      => str
      case NameMapper.CamelCase => CaseUtils.toCamelCase(str, capitalizeFirstLetter, '_')
    }

  implicit class ColumnTypeOps(tpe: ColumnType) {
    def safeTypeName: String = tpe match {
      case p: ColumnType.Predefined         => p.name
      case ColumnType.Enumeration(enumName, _) => enumName.safeTypeName
      case ColumnType.Unknown(originalName)    => s"<UNKNOWN> // ${originalName}"
    }
  }

  implicit class StrOps(str: String) {
    def safeTypeName: String =
      transformName(str, config.typeNameMapper, capitalizeFirstLetter = true)
    def safeColNameIdentifier: String =
      transformName(str, config.colNameIdentifierMapper, capitalizeFirstLetter = false)
  }

}

case class SchemaConfig(
    name: String,
    baseFolder: Path,
    basePackage: String
)

sealed abstract class NameMapper
object NameMapper {
  case object Noop extends NameMapper
  case object CamelCase extends NameMapper
}

// case-class-row column name mapping is forbidden!
case class SqueryGeneratorConfig(
    colNameIdentifierMapper: NameMapper,
    typeNameMapper: NameMapper,
    rowTypeSuffix: String,
    daoTypeSuffix: String
)

object SqueryGeneratorConfig {
  val Default: SqueryGeneratorConfig =
    SqueryGeneratorConfig(
      colNameIdentifierMapper = NameMapper.CamelCase,
      typeNameMapper = NameMapper.CamelCase,
      rowTypeSuffix = "Row",
      daoTypeSuffix = "CrudDao"
    )
}
