package ba.sake.squery.generator

import java.io.File
import javax.sql.DataSource
import java.sql.{Array => _, _}
import scala.util._
import org.apache.commons.text.CaseUtils
import com.typesafe.scalalogging.Logger

class SqueryGenerator(ds: DataSource, config: SqueryGeneratorConfig = SqueryGeneratorConfig.Default) {
  private val logger = Logger(getClass.getName)

  private val Preamble = "/* DO NOT EDIT MANUALLY! Automatically generated by squery generator */"

  def generateString(schemaNames: Seq[String]): String = {
    val extractor = DbDefExtractor(ds)
    val dbDef = extractor.extract()
    val missingSchemaNames = schemaNames.toSet.diff(dbDef.schemas.map(_.name).toSet)
    if (missingSchemaNames.nonEmpty)
      throw new RuntimeException(s"Schemas do not exist in database: ${missingSchemaNames.mkString(", ")}")

    schemaNames
      .map { schemaName =>
        dbDef.schemas.find(_.name == schemaName) match {
          case Some(schemaDef) =>
            logger.info(s"Started generating schema '${schemaName}'")
            val (imports, enumDefsScala, tableDefsScala) = generateSchema(schemaDef, dbName = dbDef.name)
            val res =
              s"""|${Preamble}
                  |${imports}
                  |
                  |${enumDefsScala.mkString("\n")}
                  |
                  |${tableDefsScala.mkString("\n")}
                  |""".stripMargin
            logger.info(s"Finished generating schema '${schemaName}'")
            res
          case None =>
            throw new RuntimeException(s"Schema '${schemaName}' does not exist")
        }
      }
      .mkString("\n")
  }

  def generateFiles(schemaConfigs: Seq[SchemaConfig]): Unit = {
    val extractor = DbDefExtractor(ds)
    val dbDef = extractor.extract()
    val missingSchemaNames = schemaConfigs.map(_.name).toSet.diff(dbDef.schemas.map(_.name).toSet)
    if (missingSchemaNames.nonEmpty)
      throw new RuntimeException(s"Schemas do not exist in database: ${missingSchemaNames.mkString(", ")}")

    schemaConfigs.foreach { schemaConfig =>
      dbDef.schemas.find(_.name == schemaConfig.name) match {
        case Some(schemaDef) =>
          logger.info(s"Started generating schema '${schemaConfig.name}' into '${schemaConfig.baseFolder}'")
          val packagePath = os.RelPath(schemaConfig.basePackage.replaceAll("\\.", "/"))
          val (imports, modelDefsScala, daoDefsScala) = generateSchema(schemaDef, dbName = dbDef.name)
          modelDefsScala.foreach { modelFile =>
            val modelFileWithImports =
              s"""|${Preamble}
                  |package ${schemaConfig.basePackage}.models
                  |
                  |${imports}
                  |
                  |${modelFile.content}
                  |""".stripMargin
            os.write.over(
              schemaConfig.baseFolder / packagePath / "models" / modelFile.baseName,
              modelFileWithImports,
              createFolders = true
            )
          }
          daoDefsScala.foreach { daoFile =>
            val daoFileWithImports =
              s"""|${Preamble}
                  |package ${schemaConfig.basePackage}.daos
                  |
                  |${imports}
                  |import ${schemaConfig.basePackage}.models.*
                  |
                  |${daoFile.content}
                  |""".stripMargin
            os.write.over(
              schemaConfig.baseFolder / packagePath / "daos" / daoFile.baseName,
              daoFileWithImports,
              createFolders = true
            )
          }
          logger.info(s"Finished generating schema '${schemaConfig.name}'")
        case None =>
          throw new RuntimeException(s"Schema '${schemaConfig.name}' does not exist")
      }
    }
  }

  // (imports, models, repos)
  private def generateSchema(
      schemaDef: SchemaDef,
      dbName: String
  ): (String, Seq[GeneratedFile], Seq[GeneratedFile]) = {
    val enumDefs = schemaDef.tables.flatMap {
      _.columnDefs.map(_.scalaType).collect { case e: ColumnType.Enumeration =>
        e
      }
    }
    val enumFiles = enumDefs.map { enumDef =>
      val enumCaseDefs = enumDef.values.map { enumDefCaseValue =>
        s"    case ${enumDefCaseValue.safeIdentifier}"
      }
      val enumName = transformName(enumDef.name, config.typeNameMapper)
      val contents =
        s"""|enum ${enumName} derives SqlRead, SqlWrite:
            |${enumCaseDefs.mkString("\n")}
            |""".stripMargin
      GeneratedFile(s"${enumName}.scala", contents)
    }

    val tableFiles = schemaDef.tables.map { tableDef =>
      val columnDefsScala = tableDef.columnDefs.map { columnDef =>
        val safeTypeName = getSafeTypeName(columnDef.scalaType, config.typeNameMapper)
        val tpe = if (columnDef.metadata.isNullable) s"Option[${safeTypeName}]" else safeTypeName
        s"    ${columnDef.metadata.name.safeIdentifier}: ${tpe}"
      }
      val columnNamesScala = tableDef.columnDefs.map { columnDef =>
        s"""  inline val ${columnDef.metadata.name.safeIdentifier} = "${columnDef.metadata.name.safeIdentifier}""""
      }
      val prefixedColumnNamesScala = tableDef.columnDefs.map { columnDef =>
        s"""prefix + ${columnDef.metadata.name.safeIdentifier}"""
      }
      val caseClassName = transformName(tableDef.name, config.typeNameMapper) + config.rowTypeSuffix
      val (pkValue, pkTypeDef) = // TODO handle empty
        if (tableDef.pkColumns.length == 1) {
          val pkCol = tableDef.pkColumns.head
          (s"${pkCol.metadata.name}", s"type PK = ${pkCol.scalaType.name}")
        } else {
          val (pkColExprs, pkColDefs) = tableDef.pkColumns.map { pkCol =>
            (pkCol.metadata.name, s"${pkCol.metadata.name}: ${pkCol.scalaType.name}")
          }.unzip
          (s"${caseClassName}.PK(${pkColExprs.mkString(", ")})", s"case class PK(${pkColDefs.mkString(", ")})")
        }
      val contents =
        s"""|case class ${caseClassName}(
            |${columnDefsScala.mkString(",\n")}
            |) derives SqlReadRow {
            |  def pk: ${caseClassName}.PK = ${pkValue}
            |}
            |
            |object ${caseClassName} {
            |  inline val TableName = "${tableDef.schema}.${tableDef.name}"
            |
            |${columnNamesScala.mkString("\n")}
            |
            |  inline val * = prefixed("")
            |
            |  transparent inline def prefixed(inline prefix: String) =
            |    ${prefixedColumnNamesScala.mkString(""" + ", " + """)}
            |
            |  ${pkTypeDef}
            |}
            |""".stripMargin
      GeneratedFile(s"${caseClassName}.scala", contents)
    }

    val daoFiles = schemaDef.tables.map { tableDef =>
      val caseClassName = transformName(tableDef.name, config.typeNameMapper) + config.rowTypeSuffix
      val daoClassName = transformName(tableDef.name, config.typeNameMapper) + "CrudDao"

      def byIdWhereExpr(prefix: String) = if (tableDef.hasCompositePk) {
        tableDef.pkColumns
          .map { pkCol =>
            s"${pkCol.metadata.name} = $${${prefix}.${pkCol.metadata.name.safeIdentifier}}"
          }
          .mkString(" AND ")
      } else {
        val pkCol = tableDef.pkColumns.head
        if (prefix == "row") s"${pkCol.metadata.name} = $${row.${pkCol.metadata.name.safeIdentifier}}"
        else s"${pkCol.metadata.name} = $${id}"
      }


      def genCountAllQuery: String =
        s"""|  def countAll(): DbAction[Int] =
            |    sql"SELECT COUNT(*) FROM $${${caseClassName}.TableName}".readValue()
            |""".stripMargin
      def genFindAllQuery: String =
        s"""|  def findAll(): DbAction[Seq[${caseClassName}]] =
            |    sql"SELECT $${${caseClassName}.*} FROM $${${caseClassName}.TableName}".readRows()
            |""".stripMargin

      def genFindById: Option[String] = Option.when(tableDef.hasPk) {
        val whereExpr = byIdWhereExpr("id")
        s"""|  def findById(id: ${caseClassName}.PK): DbAction[${caseClassName}] =
            |    sql"SELECT $${${caseClassName}.*} FROM $${${caseClassName}.TableName} WHERE ${whereExpr}".readRow()
            |""".stripMargin
      }
      def genFindByIdOpt: Option[String] = Option.when(tableDef.hasPk) {
        val whereExpr = byIdWhereExpr("id")
        s"""|  def findByIdOpt(id: ${caseClassName}.PK): DbAction[Option[${caseClassName}]] =
            |    sql"SELECT $${${caseClassName}.*} FROM $${${caseClassName}.TableName} WHERE ${whereExpr}".readRowOpt()
            |""".stripMargin
      }
      def genInsert: String = {
        val insertExpr = tableDef.columnDefs
          .map { colDef =>
            s"$${row.${colDef.metadata.name.safeIdentifier}}"
          }
          .mkString(", ")
        val whereExpr = byIdWhereExpr("id")
        s"""|  def insert(row: ${caseClassName}): DbAction[Unit] =
            |    sql""\"INSERT INTO $${${caseClassName}.TableName} VALUES (
            |      ${insertExpr}
            |    )""\".insert()
            |""".stripMargin
      }
      def genUpdateById: Option[String] = Option.when(tableDef.hasPk) {
        val updateExpr = tableDef.nonPkColDefs
          .map { colDef =>
            s"        ${colDef.metadata.name} = $${row.${colDef.metadata.name.safeIdentifier}}"
          }
          .mkString(",\n")
        val whereExpr = byIdWhereExpr("row")
        s"""|  def updateById(row: ${caseClassName}): DbAction[Unit] =
            |    sql""\"
            |      UPDATE $${${caseClassName}.TableName}
            |      SET 
            |${updateExpr}
            |      WHERE ${whereExpr}
            |    ""\".update()
            |""".stripMargin
      }
      def genDeleteById: Option[String] = Option.when(tableDef.hasPk) {
        val whereExpr = byIdWhereExpr("id")
        s"""|  def deleteById(id: ${caseClassName}.PK): DbAction[Unit] =
            |    sql"DELETE FROM $${${caseClassName}.TableName} WHERE ${whereExpr}".update()
            |""".stripMargin
      }

      // must have a PK to work
      val optionalSelectQueries = Seq(
        genFindById,
        genFindByIdOpt
      ).flatten.mkString("\n\n")
      val optionalUpdateQueries = Seq(
        genUpdateById,
        genDeleteById
      ).flatten.mkString("\n\n")

      val contents =
        s"""|trait ${daoClassName} {
            |${genCountAllQuery}

            |${genFindAllQuery}
            |
            |${optionalSelectQueries}
            |
            |${genInsert}
            |
            |${optionalUpdateQueries}
            |}
            |
            |object ${daoClassName} extends ${daoClassName} {
            |
            |}
            |""".stripMargin
      GeneratedFile(s"${daoClassName}.scala", contents)
    }

    val squeryDbPackage =
      if (dbName.contains("postgres")) "postgres"
      else if (dbName.contains("mysql")) "mysql"
      else if (dbName.contains("mariadb")) "mariadb"
      else if (dbName.contains("oracle")) "oracle"
      else if (dbName.contains("h2")) "h2"
      else throw new RuntimeException(s"Unknown database type $dbName")

    val imports =
      s"""|import java.time.*
          |import java.util.UUID
          |import ba.sake.squery.{*, given}
          |import ba.sake.squery.${squeryDbPackage}.given
          |import ba.sake.squery.read.SqlRead
          |import ba.sake.squery.write.SqlWrite
          |""".stripMargin

    (imports, enumFiles ++ tableFiles, daoFiles)
  }

  private def transformName(str: String, nameMapper: NameMapper): String =
    nameMapper match {
      case NameMapper.Noop      => str
      case NameMapper.CamelCase => CaseUtils.toCamelCase(str, true, '_')
    }

  private def getSafeTypeName(tpe: ColumnType, nameMapper: NameMapper): String = tpe match {
    case ColumnType.Predefined(name)              => name
    case ColumnType.Enumeration(enumName, values) => transformName(enumName, nameMapper).safeIdentifier
    case ColumnType.Unknown(originalName)         => s"<UNKNOWN> // ${originalName}"
  }

  implicit class StrOps(str: String) {
    def safeIdentifier: String =
      if (SqueryGenerator.ReservedScalaKeywords(str) || str.contains("-"))
        s"`${str}`"
      else str
  }

}

object SqueryGenerator {
  // https://www.scala-lang.org/files/archive/spec/3.4/01-lexical-syntax.html#regular-keywords
  private val ReservedScalaKeywords = s"""
    abstract  case      catch     class     def       do        else
    enum      export    extends   false     final     finally   for
    given     if        implicit  import    lazy      match     new
    null      object    override  package   private   protected return
    sealed    super     then      throw     trait     true      try
    type      val       var       while     with      yield
    :         =         <-        =>        <:        >:        #
    @         =>>       ?=>
    """.split("\\s+").map(_.trim).toSet
}

case class SchemaConfig(
    name: String,
    baseFolder: os.Path,
    basePackage: String
)

sealed abstract class NameMapper
object NameMapper {
  case object Noop extends NameMapper
  case object CamelCase extends NameMapper
}

// TODO camelCase identifiers??
case class SqueryGeneratorConfig(
    typeNameMapper: NameMapper,
    rowTypeSuffix: String
)

object SqueryGeneratorConfig {
  val Default: SqueryGeneratorConfig =
    SqueryGeneratorConfig(typeNameMapper = NameMapper.CamelCase, rowTypeSuffix = "Row")
}

case class GeneratedFile(
    baseName: String,
    content: String
)
