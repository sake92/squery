package ba.sake.squery.generator

import java.io.File
import javax.sql.DataSource
import java.sql.{Array => _, _}
import scala.util._
import org.apache.commons.text.CaseUtils
import com.typesafe.scalalogging.Logger

class SqueryGenerator(ds: DataSource, config: SqueryGeneratorConfig = SqueryGeneratorConfig.Default) {
  private val logger = Logger(getClass.getName)

  private val Preamble = "/* DO NOT EDIT MANUALLY! Automatically generated by squery generator */"

  def generateString(schemaNames: Seq[String]): String = {
    val extractor = DbDefExtractor(ds)
    val dbDef = extractor.extract()
    val missingSchemaNames = schemaNames.toSet.diff(dbDef.schemas.map(_.name).toSet)
    if (missingSchemaNames.nonEmpty)
      throw new RuntimeException(s"Schemas do not exist in database: ${missingSchemaNames.mkString(", ")}")

    schemaNames
      .map { schemaName =>
        dbDef.schemas.find(_.name == schemaName) match {
          case Some(schemaDef) =>
            logger.info(s"Started generating schema '${schemaName}'")
            val (imports, enumDefsScala, tableDefsScala) = generateSchema(schemaDef, dbType = dbDef.tpe)
            val res =
              s"""|${Preamble}
                  |${imports}
                  |
                  |${enumDefsScala.mkString("\n")}
                  |
                  |${tableDefsScala.mkString("\n")}
                  |""".stripMargin
            logger.info(s"Finished generating schema '${schemaName}'")
            res
          case None =>
            throw new RuntimeException(s"Schema '${schemaName}' does not exist")
        }
      }
      .mkString("\n")
  }

  def generateFiles(schemaConfigs: Seq[SchemaConfig]): Unit = {
    val extractor = DbDefExtractor(ds)
    val dbDef = extractor.extract()
    val missingSchemaNames = schemaConfigs.map(_.name).toSet.diff(dbDef.schemas.map(_.name).toSet)
    if (missingSchemaNames.nonEmpty)
      throw new RuntimeException(s"Schemas do not exist in database: ${missingSchemaNames.mkString(", ")}")

    schemaConfigs.foreach { schemaConfig =>
      dbDef.schemas.find(_.name == schemaConfig.name) match {
        case Some(schemaDef) =>
          logger.info(s"Started generating schema '${schemaConfig.name}' into '${schemaConfig.baseFolder}'")
          val packagePath = os.RelPath(schemaConfig.basePackage.replaceAll("\\.", "/"))
          val (imports, modelDefsScala, daoDefsScala) = generateSchema(schemaDef, dbType = dbDef.tpe)
          modelDefsScala.foreach { modelFile =>
            val modelFileWithImports =
              s"""|${Preamble}
                  |package ${schemaConfig.basePackage}.models
                  |
                  |${imports}
                  |
                  |${modelFile.content}
                  |""".stripMargin
            os.write.over(
              schemaConfig.baseFolder / packagePath / "models" / modelFile.baseName,
              modelFileWithImports,
              createFolders = true
            )
          }
          daoDefsScala.foreach { daoFile =>
            val daoFileWithImports =
              s"""|${Preamble}
                  |package ${schemaConfig.basePackage}.daos
                  |
                  |${imports}
                  |import ${schemaConfig.basePackage}.models.*
                  |
                  |${daoFile.content}
                  |""".stripMargin
            os.write.over(
              schemaConfig.baseFolder / packagePath / "daos" / daoFile.baseName,
              daoFileWithImports,
              createFolders = true
            )
          }
          logger.info(s"Finished generating schema '${schemaConfig.name}'")
        case None =>
          throw new RuntimeException(s"Schema '${schemaConfig.name}' does not exist")
      }
    }
  }

  // (imports, models, repos)
  private def generateSchema(
      schemaDef: SchemaDef,
      dbType: DbType
  ): (String, Seq[GeneratedFile], Seq[GeneratedFile]) = {
    val enumDefs = schemaDef.tables.flatMap {
      _.columnDefs.map(_.scalaType).collect { case e: ColumnType.Enumeration =>
        e
      }
    }
    val enumFiles = enumDefs.map { enumDef =>
      val enumCaseDefs = enumDef.values.map { enumDefCaseValue =>
        s"    case ${enumDefCaseValue.safeName}"
      }
      val enumName = enumDef.safeTypeName
      val contents =
        s"""|enum ${enumName} derives SqlRead, SqlWrite:
            |${enumCaseDefs.mkString("\n")}
            |""".stripMargin
      GeneratedFile(s"${enumName}.scala", contents)
    }

    val tableFiles = schemaDef.tables.map { tableDef =>
      val columnDefsScala = tableDef.columnDefs.map { columnDef =>
        val safeTypeName = columnDef.scalaType.safeTypeName
        val tpe = if (columnDef.metadata.isNullable) s"Option[${safeTypeName}]" else safeTypeName
        s"    ${columnDef.metadata.name.safeName}: ${tpe}"
      }
      val columnValNamesScala = tableDef.columnDefs.map { columnDef =>
        s"""  inline val ${columnDef.metadata.name.safeColNameIdentifier} = "${columnDef.metadata.name}""""
      }
      val columnNamesScala = tableDef.columnDefs.map(_.metadata.name.safeColNameIdentifier)
      val withPrefixColumnNamesScala = columnNamesScala.map { columnName =>
        s"""prefix + "." + ${columnName}"""
      }
      val caseClassName = tableDef.name.safeTypeName + config.rowTypeSuffix
      val (pkValue, pkTypeDef) = // TODO handle empty
        if (tableDef.pkColumns.length == 1) {
          val pkCol = tableDef.pkColumns.head
          (s"${pkCol.metadata.name.safeName}", s"type PK = ${pkCol.scalaType.safeTypeName}")
        } else {
          val (pkColExprs, pkColDefs) = tableDef.pkColumns.map { pkCol =>
            (pkCol.metadata.name.safeName, s"${pkCol.metadata.name.safeName}: ${pkCol.scalaType.safeTypeName}")
          }.unzip
          (s"${caseClassName}.PK(${pkColExprs.mkString(", ")})", s"case class PK(${pkColDefs.mkString(", ")})")
        }
      val contents =
        s"""|case class ${caseClassName}(
            |${columnDefsScala.mkString(",\n")}
            |) derives SqlReadRow {
            |  def pk: ${caseClassName}.PK = ${pkValue}
            |}
            |
            |object ${caseClassName} {
            |  inline val tableName = "${tableDef.schema}.${tableDef.name}"
            |
            |${columnValNamesScala.mkString("\n")}
            |
            |  inline val allCols =
            |    ${columnNamesScala.mkString(""" + ", " + """)}
            |
            |  transparent inline def allColsWithPrefix(inline prefix: String) =
            |    ${withPrefixColumnNamesScala.mkString(""" + ", " + """)}
            |
            |  ${pkTypeDef}
            |}
            |""".stripMargin
      GeneratedFile(s"${caseClassName}.scala", contents)
    }

    val daoFiles = schemaDef.tables.map { tableDef =>
      val caseClassName = tableDef.name.safeTypeName + config.rowTypeSuffix
      val daoClassName = tableDef.name.safeTypeName + "CrudDao"

      def byIdWhereExpr(prefix: String) = if (tableDef.hasCompositePk) {
        tableDef.pkColumns
          .map { pkCol =>
            s"${pkCol.metadata.name} = $${${prefix}.${pkCol.metadata.name.safeName}}"
          }
          .mkString(" AND ")
      } else {
        val pkCol = tableDef.pkColumns.head
        if (prefix == "row") s"${pkCol.metadata.name} = $${row.${pkCol.metadata.name.safeName}}"
        else s"${pkCol.metadata.name} = $${id}"
      }

      def genCountAllQuery: String =
        s"""|  def countAll(): DbAction[Int] =
            |    sql"SELECT COUNT(*) FROM $${${caseClassName}.tableName}".readValue()
            |""".stripMargin
      def genFindAllQuery: String =
        s"""|  def findAll(): DbAction[Seq[${caseClassName}]] =
            |    sql"SELECT $${${caseClassName}.allCols} FROM $${${caseClassName}.tableName}".readRows()
            |""".stripMargin

      def genFindById: Option[String] = Option.when(tableDef.hasPk) {
        val whereExpr = byIdWhereExpr("id")
        s"""|  def findById(id: ${caseClassName}.PK): DbAction[${caseClassName}] =
            |    sql"SELECT $${${caseClassName}.allCols} FROM $${${caseClassName}.tableName} WHERE ${whereExpr}".readRow()
            |""".stripMargin
      }
      def genFindByIdOpt: Option[String] = Option.when(tableDef.hasPk) {
        val whereExpr = byIdWhereExpr("id")
        s"""|  def findByIdOpt(id: ${caseClassName}.PK): DbAction[Option[${caseClassName}]] =
            |    sql"SELECT $${${caseClassName}.allCols} FROM $${${caseClassName}.tableName} WHERE ${whereExpr}".readRowOpt()
            |""".stripMargin
      }
      def genInsert: String = {
        // TODO if cols are autoinc
        // https://www.jooq.org/doc/latest/manual/sql-building/sql-statements/insert-statement/insert-returning/
        val insertExpr = tableDef.columnDefs
          .map { colDef =>
            s"$${row.${colDef.metadata.name.safeName}}"
          }
          .mkString(", ")
        val whereExpr = byIdWhereExpr("id")
        if (dbType.supportsReturning)
          s"""|  def insert(row: ${caseClassName}): DbAction[${caseClassName}] =
              |    sql""\"
              |      INSERT INTO $${${caseClassName}.tableName}($${${caseClassName}.allCols})
              |      VALUES (${insertExpr})
              |      RETURNING $${${caseClassName}.allCols}
              |    ""\".insertReturningRow()
              |""".stripMargin
        else
          s"""|  def insert(row: ${caseClassName}): DbAction[Unit] =
              |    sql""\"
              |      INSERT INTO $${${caseClassName}.tableName}($${${caseClassName}.allCols})
              |      VALUES(${insertExpr})
              |    ""\".insert()
              |""".stripMargin
      }
      def genUpdateById: Option[String] = Option.when(tableDef.hasPk) {
        val updateExpr = tableDef.nonPkColDefs
          .map { colDef =>
            s"        ${colDef.metadata.name} = $${row.${colDef.metadata.name.safeName}}"
          }
          .mkString(",\n")
        val whereExpr = byIdWhereExpr("row")
        s"""|  def updateById(row: ${caseClassName}): DbAction[Unit] =
            |    sql""\"
            |      UPDATE $${${caseClassName}.tableName}
            |      SET 
            |${updateExpr}
            |      WHERE ${whereExpr}
            |    ""\".update()
            |""".stripMargin
      }
      def genDeleteById: Option[String] = Option.when(tableDef.hasPk) {
        val whereExpr = byIdWhereExpr("id")
        s"""|  def deleteById(id: ${caseClassName}.PK): DbAction[Unit] =
            |    sql"DELETE FROM $${${caseClassName}.tableName} WHERE ${whereExpr}".update()
            |""".stripMargin
      }

      // must have a PK to work
      val optionalSelectQueries = Seq(
        genFindById,
        genFindByIdOpt
      ).flatten.mkString("\n")
      val optionalUpdateQueries = Seq(
        genUpdateById,
        genDeleteById
      ).flatten.mkString("\n")

      val contents =
        s"""|trait ${daoClassName} {
            |${genCountAllQuery}
            |
            |${genFindAllQuery}
            |
            |${optionalSelectQueries}
            |
            |${genInsert}
            |
            |${optionalUpdateQueries}
            |}
            |
            |object ${daoClassName} extends ${daoClassName}
            |""".stripMargin
      GeneratedFile(s"${daoClassName}.scala", contents)
    }

    val imports =
      s"""|import java.time.*
          |import java.util.UUID
          |import ba.sake.squery.{*, given}
          |import ba.sake.squery.${dbType.squeryPackage}.given
          |import ba.sake.squery.read.SqlRead
          |import ba.sake.squery.write.SqlWrite
          |""".stripMargin

    (imports, enumFiles ++ tableFiles, daoFiles)
  }

  private def transformName(str: String, nameMapper: NameMapper, capitalizeFirstLetter: Boolean): String =
    nameMapper match {
      case NameMapper.Noop      => str
      case NameMapper.CamelCase => CaseUtils.toCamelCase(str, capitalizeFirstLetter, '_')
    }

  implicit class ColumnTypeOps(tpe: ColumnType) {
    def safeTypeName: String = tpe match {
      case ColumnType.Predefined(name)         => name
      case ColumnType.Enumeration(enumName, _) => enumName.safeTypeName
      case ColumnType.Unknown(originalName)    => s"<UNKNOWN> // ${originalName}"
    }
  }

  implicit class StrOps(str: String) {
    def safeName: String =
      if (SqueryGenerator.ReservedScalaKeywords(str) || str.contains("-"))
        s"`${str}`"
      else str
    def safeTypeName: String =
      transformName(str, config.typeNameMapper, capitalizeFirstLetter = true).safeName
    def safeColNameIdentifier: String =
      transformName(str, config.colNameIdentifierMapper, capitalizeFirstLetter = false).safeName
  }

}

object SqueryGenerator {
  // https://www.scala-lang.org/files/archive/spec/3.4/01-lexical-syntax.html#regular-keywords
  private val ReservedScalaKeywords = s"""
    abstract  case      catch     class     def       do        else
    enum      export    extends   false     final     finally   for
    given     if        implicit  import    lazy      match     new
    null      object    override  package   private   protected return
    sealed    super     then      throw     trait     true      try
    type      val       var       while     with      yield
    :         =         <-        =>        <:        >:        #
    @         =>>       ?=>
    """.split("\\s+").map(_.trim).toSet
}

case class SchemaConfig(
    name: String,
    baseFolder: os.Path,
    basePackage: String
)

sealed abstract class NameMapper
object NameMapper {
  case object Noop extends NameMapper
  case object CamelCase extends NameMapper
}

// case-class-row column name mapping is forbidden!
case class SqueryGeneratorConfig(
    colNameIdentifierMapper: NameMapper,
    typeNameMapper: NameMapper,
    rowTypeSuffix: String
)

object SqueryGeneratorConfig {
  val Default: SqueryGeneratorConfig =
    SqueryGeneratorConfig(
      colNameIdentifierMapper = NameMapper.CamelCase,
      typeNameMapper = NameMapper.CamelCase,
      rowTypeSuffix = "Row"
    )
}

case class GeneratedFile(
    baseName: String,
    content: String
)
